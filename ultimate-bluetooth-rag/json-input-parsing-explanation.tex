\documentclass[11pt,a4paper]{article}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{geometry}
\usepackage{amsmath,amsfonts,amssymb}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{hyperref}
\usepackage{fancyhdr}
\usepackage{titlesec}
\usepackage{enumitem}
\usepackage{graphicx}
\usepackage{booktabs}
\usepackage{array}

% Page setup
\geometry{margin=1in}
\pagestyle{fancy}
\fancyhf{}
\fancyhead[L]{JSON Input Parsing in Bluetooth RAG Agent}
\fancyhead[R]{\thepage}
\fancyfoot[C]{Cloudflare Workers AI Integration}

% Code styling
\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}

\lstdefinestyle{mystyle}{
    backgroundcolor=\color{backcolour},   
    commentstyle=\color{codegreen},
    keywordstyle=\color{magenta},
    numberstyle=\tiny\color{codegray},
    stringstyle=\color{codepurple},
    basicstyle=\ttfamily\footnotesize,
    breakatwhitespace=false,         
    breaklines=true,                 
    captionpos=b,                    
    keepspaces=true,                 
    numbers=left,                    
    numbersep=5pt,                  
    showspaces=false,                
    showstringspaces=false,
    showtabs=false,                  
    tabsize=2
}

\lstset{style=mystyle}

% Section styling
\titleformat{\section}{\large\bfseries\color{blue!70!black}}{\thesection}{1em}{}
\titleformat{\subsection}{\normalsize\bfseries\color{blue!50!black}}{\thesubsection}{1em}{}

\title{\textbf{JSON Input Format Handling \& Parsing\\in Bluetooth RAG Agent Text Generation Flow}}
\author{Technical Documentation\\Cloudflare Workers AI Integration}
\date{\today}

\begin{document}

\maketitle

\begin{abstract}
This document provides a comprehensive technical analysis of the JSON input format handling and parsing mechanisms implemented in the Bluetooth RAG (Retrieval-Augmented Generation) Agent's text generation pipeline. The system employs sophisticated multi-layer parsing strategies to handle diverse response formats from Cloudflare Workers AI models, ensuring robust and reliable text extraction across different model architectures and API schemas.
\end{abstract}

\tableofcontents
\newpage

\section{Introduction}

The Bluetooth RAG Agent implements a sophisticated text generation flow that must handle the inherent variability in JSON response formats from Cloudflare Workers AI models. This document details the comprehensive parsing strategy employed to ensure reliable text extraction across different model architectures and evolving API schemas.

\subsection{System Context}

The agent operates within a multi-agent architecture where text generation is critical for:
\begin{itemize}[itemsep=0pt]
    \item Answer synthesis from retrieved Bluetooth documentation
    \item Query expansion for improved retrieval recall
    \item Conversation summarization for memory management
    \item Cross-document synthesis and validation
\end{itemize}

\section{Two-Tier Input Strategy}

The system employs a dual-format approach to maximize compatibility with various Cloudflare Workers AI models.

\subsection{Primary: Chat Messages Format}

The primary input strategy utilizes the OpenAI-compatible chat format:

\begin{lstlisting}[language=JavaScript, caption=Chat Messages Format Implementation]
const messages = [
  { role: "system", content: systemPrompt },
  { role: "user", content: userPrompt },
];

const res = await env.AI.run(env.MODEL_GENERATION, { 
  messages, 
  temperature: 0.2, 
  max_tokens: 800 
});
\end{lstlisting}

This format is preferred for its structured approach and compatibility with conversational AI models.

\subsection{Fallback: Plain Input Format}

When chat format fails, the system degrades gracefully to a plain text input schema:

\begin{lstlisting}[language=JavaScript, caption=Plain Input Format Fallback]
const inputText = `${systemPrompt}\n\n${userPrompt}`;

const res2 = await env.AI.run(env.MODEL_GENERATION, { 
  input: inputText, 
  temperature: 0.2, 
  max_tokens: 800 
});
\end{lstlisting}

This ensures compatibility with models that expect simple text completion interfaces.

\section{Advanced JSON Response Parsing}

The core of the system's resilience lies in its sophisticated \texttt{extractText()} function, which implements a multi-path extraction strategy.

\subsection{Multi-Path Extraction Algorithm}

The extraction algorithm employs a systematic approach to handle diverse JSON response schemas:

\begin{lstlisting}[language=JavaScript, caption=Multi-Path Extraction Strategy]
const extractText = (res: any): string | null => {
  const tryGet = (getters: Array<() => unknown>) => {
    for (const g of getters) {
      try {
        const v = g();
        if (typeof v === "string" && v.trim()) return v;
        if (Array.isArray(v) && typeof v[0] === "string" && v[0].trim()) 
          return v[0];
        // Handle nested content arrays
        if (Array.isArray(v) && v[0]?.content && 
            Array.isArray(v[0].content) && 
            typeof v[0].content[0]?.text === "string") {
          return v[0].content[0].text;
        }
      } catch { /* ignore */ }
    }
    return null;
  };
  // ... continued
};
\end{lstlisting}

\subsection{Response API Shape Handling}

The system specifically handles the Cloudflare Responses API format:

\begin{lstlisting}[language=JavaScript, caption=Responses API Shape Handler]
// Handle Responses API shape: { object: "response", output: [...] }
try {
  const out = res.output;
  if (Array.isArray(out) && out.length > 0) {
    // Prefer the last message-like block
    for (let i = out.length - 1; i >= 0; i--) {
      const block = out[i];
      const contentArr = block?.content;
      if (Array.isArray(contentArr)) {
        // Find first item with string text
        for (const it of contentArr) {
          const txt = it?.text;
          if (typeof txt === "string" && txt.trim()) return txt;
        }
      }
    }
  }
} catch { /* ignore */ }
\end{lstlisting}

\subsection{Comprehensive Path Fallbacks}

The system implements a comprehensive fallback hierarchy:

\begin{lstlisting}[language=JavaScript, caption=Comprehensive Fallback Paths]
return tryGet([
  () => res.choices?.[0]?.message?.content,          // OpenAI-style chat
  () => res.result?.choices?.[0]?.message?.content,  // Nested result wrapper
  () => res.output_text,                             // Direct text output
  () => res.result?.output_text,                     // Wrapped text output
  () => res.content,                                 // Simple content field
  () => res.result?.content,                         // Wrapped content
  () => res.response,                                // Response field
  () => res.result?.response,                        // Wrapped response
  () => res.text,                                    // Plain text field
  () => res.result?.text,                           // Wrapped text
  () => res.outputs,                                // Array outputs
  () => res.result?.output,                         // Wrapped output arrays
]);
\end{lstlisting}

\section{Error Handling \& Progressive Degradation}

The system implements a three-tier error handling strategy ensuring graceful degradation under all circumstances.

\subsection{Progressive Degradation Chain}

\begin{enumerate}
    \item \textbf{Primary Attempt}: Chat format with \texttt{extractText()}
    \item \textbf{Secondary Attempt}: Input format with \texttt{extractText()}
    \item \textbf{Debug Fallback}: JSON serialization for inspection
\end{enumerate}

\begin{lstlisting}[language=JavaScript, caption=Progressive Degradation Implementation]
try {
  const res = await env.AI.run(env.MODEL_GENERATION, { 
    messages, temperature: 0.2, max_tokens: 800 
  });
  const content = extractText(res);
  if (typeof content === "string" && content.trim().length > 0) 
    return content;
} catch (_) {
  // fall through to input-style
}

// Fallback: input-style schema
const res2 = await env.AI.run(env.MODEL_GENERATION, { 
  input: inputText, temperature: 0.2, max_tokens: 800 
});
const content2 = extractText(res2);
if (typeof content2 === "string" && content2.trim()) return content2;

// Debug fallback: JSON serialization
return JSON.stringify(res2 ?? {}, null, 2);
\end{lstlisting}

\section{Specialized Parsing for Different Use Cases}

The system implements task-specific parsing strategies optimized for different components of the multi-agent architecture.

\subsection{Query Expansion Parsing}

Query expansion requires parsing multiple alternative phrasings from model output:

\begin{lstlisting}[language=JavaScript, caption=Query Expansion Parsing Logic]
const tryExtract = (res: any): string[] => {
  const text = (
    res?.choices?.[0]?.message?.content ||
    res?.output_text ||
    res?.content ||
    res?.result?.output_text ||
    res?.result?.text ||
    (Array.isArray(res?.output) && 
     res.output[res.output.length - 1]?.content?.[0]?.text) ||
    res?.text ||
    ""
  );
  
  // Parse lines and clean formatting
  const lines = s.split(/\r?\n/).map(l => l.trim()).filter(Boolean);
  const out: string[] = [];
  for (const l of lines) {
    // Remove list markers
    const li = l.replace(/^[-*\d.\)\]]+\s*/, "").trim(); 
    if (li && !out.includes(li)) out.push(li);
  }
  return out;
};
\end{lstlisting}

\subsection{Re-ranking Result Parsing}

The re-ranking component requires structured data extraction:

\begin{lstlisting}[language=JavaScript, caption=Re-ranking Result Parser]
const parse = (res: any): Array<{ index: number; score: number }> => {
  const candidates = res?.results ?? res?.data ?? res?.output ?? 
                    res?.result?.results ?? res?.result?.data ?? [];
  if (Array.isArray(candidates)) {
    return candidates.map((r: any, i: number) => ({
      index: Number(r?.index ?? r?.document ?? r?.doc ?? i) || 0,
      score: Number(r?.relevance_score ?? r?.score ?? 
                   r?.relevance ?? 0) || 0,
    }));
  }
  return [];
};
\end{lstlisting}

\section{System Architecture Benefits}

\subsection{Key Features Analysis}

\begin{table}[h!]
\centering
\begin{tabular}{|p{3cm}|p{10cm}|}
\hline
\textbf{Feature} & \textbf{Description} \\
\hline
\textbf{Resilient Multi-Path} & Handles 10+ different response schemas with graceful fallbacks for unknown formats \\
\hline
\textbf{Model-Agnostic} & Works with different Workers AI models and adapts to schema changes automatically \\
\hline
\textbf{Debug-Friendly} & JSON serialization for unknown responses with detailed error handling \\
\hline
\textbf{Content Validation} & Ensures non-empty string responses with whitespace trimming \\
\hline
\textbf{Format-Specific} & Optimized parsing for chat vs. completion, list parsing, and structured data \\
\hline
\end{tabular}
\caption{Key Features of the JSON Parsing System}
\end{table}

\subsection{Design Rationale}

The comprehensive parsing strategy addresses several critical challenges:

\begin{itemize}
    \item \textbf{Cloudflare Workers AI Variability}: Different models return different JSON schemas
    \item \textbf{API Evolution}: Handles schema changes without breaking the system
    \item \textbf{Error Resilience}: Multiple fallback paths prevent catastrophic failures
    \item \textbf{Development Support}: Debug output facilitates troubleshooting
    \item \textbf{Performance Optimization}: Efficient sequential testing of common patterns first
\end{itemize}

\section{Implementation Considerations}

\subsection{Performance Characteristics}

The parsing system is optimized for:
\begin{itemize}
    \item \textbf{Low Latency}: Sequential testing prioritizes common response patterns
    \item \textbf{Memory Efficiency}: Minimal object creation during parsing
    \item \textbf{Error Tolerance}: Graceful handling of malformed responses
\end{itemize}

\subsection{Maintainability Features}

\begin{itemize}
    \item \textbf{Modular Design}: Each parsing strategy is independently testable
    \item \textbf{Extensible Architecture}: New response formats can be easily added
    \item \textbf{Debug Instrumentation}: Comprehensive logging for troubleshooting
\end{itemize}

\section{Conclusion}

The JSON input format handling and parsing system represents a robust, production-ready solution designed to handle the inherent variability in AI model responses while maintaining system reliability. The multi-tier approach with comprehensive fallback strategies ensures consistent operation across different Cloudflare Workers AI models and API evolution cycles.

The system's design principles of resilience, adaptability, and maintainability make it well-suited for production deployment in the Bluetooth RAG Agent's multi-agent architecture, providing a solid foundation for reliable text generation across all system components.

\subsection{Future Enhancements}

Potential improvements could include:
\begin{itemize}
    \item Machine learning-based response format prediction
    \item Adaptive parsing strategy selection based on model performance
    \item Enhanced validation with semantic content analysis
    \item Real-time monitoring of parsing success rates
\end{itemize}

\end{document}
